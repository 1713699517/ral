% Random access list.

% O(1)
List = ral:empty(). % it is just [], and will be, you can use it in pattern matching

% O(1)
NewList = ral:cons(something, List).

% O(1)
something = ral:head(NewList).

% O(n)
List2 = ral:from_list([b,c,d,e,f,g,h,i,j]).

% O(log n) - worst case
e = ral:nth(4, List2).

% O(log n) - worst case
List3 = ral:nthtail(4, List2).
[f,g,h,i,j] = ral:to_list(List3).


% O(log_2 n)
9 = ral:length(List2).

% O(1)
true = ral:is_empty(List).
false = ral:is_empty(NewList).

% O(1)
List4 = ral:cons(a, List2).

% O(n) + O(2 * log_2 n) of additional stack space
[a,b,c,d,e,f,g,h,i,j] = ral:to_list(List4).


% O(2 * log_2 n)
j = ral:last(List4).

% O(n)
% ral:foldl/3, ral:foldr/3, ral:map/2, ral:foreach/2, ral:mapfoldl/3, ral:mapfoldl/3, ral:dropwhile/2
% Note: foldr should be more effective than lists:foldl (will only use O(log n) additional stack space)


% there is no filter/2, min/1, max/1, and other function which are not more efficient than just foldl

